(load-file "src/opennlp.clj")
(load-file "src/opennlp2.clj")
(load-file "src/conduit.clj")
(load-file "src/lamina.clj")
(load-file "src/lamina1.clj")
(load-file "src/lamina2.clj")
(import '(java.io ByteArrayInputStream ByteArrayOutputStream)
           (java.security KeyPairGenerator SecureRandom))
(load-file "src/alice.clj")
(load-file "src/frinj.clj")
(load-file "src/jsonpath.clj")
(use '[json-path])
(at-path "$.hello" "{:hello \"world\"}") 
(use '[cheshire.core])
(at-path "$.foo" (parse-string "{\"foo\":\"bar\"}"))
(parse-string "{\"foo\":\"bar\"}")
(at-path "$.foo" (parse-string "{\"foo\":\"bar\"}"))
(at-path "$.foo" (parse-string (generate-string {:foo ["a", "b", "c"]})))
(at-path "$.foo.*" (parse-string (generate-string {:foo ["a", "b", "c"]})))
(at-path "$." (parse-string "{\"foo\":\"bar\"}"))
(at-path "$.foo" (parse-string "{\":foo\":\"bar\"}"))
(parse-string "{\":foo\":\"bar\"}")
(at-path "$." (parse-string "{\":foo\":\"bar\"}"))
(at-path "$." (parse-string "{\"foo\":\"[bar]\"}"))
(at-path "$." (parse-string "{\"foo\":[\"bar\"]}"))
(at-path "$.foo" (parse-string "{\"foo\":[\"bar\"]}"))
(parse-string "{\":foo\":\"bar\"}" (fn [k] (keyword k)))
(parse-string "{\"foo\":\"bar\"}" (fn [k] (keyword k)))
(at-path "$." (parse-string "{\"foo\":\"bar\"}" (fn [k] (keyword k))))
(at-path "$.foo" (parse-string "{\"foo\":\"bar\"}" (fn [k] (keyword k))))
(load-file "src/netz.clj")
(ns your-namespace
)
(ns your-namespace
  (:require [netz.core :as netz]))
(def examples [[[0 0] [1]]
               [[0 1] [0]]
               [[1 0] [0]]
               [[1 1] [1]]])
(def network (netz/train examples {:hidden-neurons [0]}))
(netz/run network [0 0])
(def network (netz/train examples {:hidden-neurons [1]}))
(netz/run network [0 0])
(netz/run network [0 0]))
(require '[netz.core :as netz])
(def network (netz/train examples {:hidden-neurons [0]}))
(def network (netz/train examples {:hidden-neurons [1]}))
(netz/run network [0 0])
(netz/run network [0 1])
(netz/run network [1 1])
(load-file "src/infer.clj")
(doc "infer")
(doc infer)
(doc 'infer)
(use 'infer.uniclass)
(use '[infer.uniclass])
(use 'infer.uniclass)
(use 'infer.core)
(diff-vec {:a 1 :c 1} {:b 1 :a -0.4})
(load-file "src/shake.clj")
(uname -a)
(sh/uname -a)
(def a (sh/uname -a))
a
(print (slurp (input-stream (sh/uname -a))))
(use 'clojure.java.io)
(print (slurp (input-stream (sh/uname -a))))
(def a (slurp (input-stream (sh/uname -a))))
(sh/ps -axj)
(input-stream (sh/ps -axj))
(slurp (input-stream (sh/ps -axj)))
(print (slurp (input-stream (sh/uname -a))))
sh/input-stream
input-stream
(input-stream (sh/ls -al))
(sh/ls -al
)
(alter-var-root (var sh/*print-output*) (fn[_] false))
(sh/ls -al)
(def un (slurp (input-stream (sh/uname -a)))))
(def un (slurp (input-stream (sh/uname -a))))
un
(load-file "src/timely.clj")
; create a schedule to repeat every minute
(def item (scheduled-item
            (each-minute)
            (test-print-fn "Scheduled using start-schedule")))
; start the item
(def sched-id (start-schedule item))
; sleep for a minute
(Thread/sleep (* 1000 60 2))
; stop the item
(end-schedule sched-id)
(load-file "src/hiccup.clj")
(load-file "src/at_at.clj")
(System/in)
(SimpleCalcParser/main [])
(SimpleCalcParser/main (as-array []))
(SimpleCalcParser/main (to-array []))
(SimpleCalcParser/main (into-array String []))
(SimpleCalcParser/main (into-array String ["source.txt"]))
(SimpleCalcParser/main (into-array String ["antlr.txt"]))
(SimpleCalcParser/main (into-array String ["src/antlr.txt"]))
(load-file "src/grep.clj")
(grep #({1}) "src/antlr.txt")
(grep 1 "src/antlr.txt")
(grep "1" "src/antlr.txt")
(grep "3" "src/antlr.txt")
(use 'matchure)
(if-match [nil nil] true)
(if-match [#"hello" "hello world"] true) ;=> true
(if-match [java.lang.String "foo"] true) ;=> true
(if-match [[[?a] ?b & ?rest] [[1] 2 3 4]] (list a b rest)) ;=> (1 2 (3 4))
(if-match [(odd? ?) 1] true)
(if-match [(odd? ?) 2] true)
(when-match [[?fst & ?rst] (list 1 2)])
  (prn "asdf")
  (prn "ghjkl"))
(when-match [[?fst & ?rst] (list 1 2)]
  (prn "asdf")
  (prn "ghjkl"))
(cond-match "hello, world"
  #"foo" "matches foo"
  #"hello" "matches hello"
  ? "doesn't match either") ;=> "matches hello"
(doseq [n (range 1 101)]
  (println
    (match [(mod n 3) (mod n 5)]
      [0 0] "FizzBuzz"
      [0 _] "Fizz"
      [_ 0] "Buzz"
      :else n)))
(use '[clojure.core.match :only (match)])
(doseq [n (range 1 101)]
  (println
    (match [(mod n 3) (mod n 5)]
      [0 0] "FizzBuzz"
      [0 _] "Fizz"
      [_ 0] "Buzz"
      :else n)))
(load-file "src/protobuffer.clj")
(load-file "src/clucy.clj")
(clucy/search index "scientist" 3)
(clucy/search index "scientist" 0)
(clucy/search index "scientist" 1)
(clucy/search index "scientist" 2)
(disk-index "tmp")
(clucy/disk-index "tmp")
(clucy/search index "name:bob" 10)
(clucy/search index "name:bob AND job:Build" 10)
(clucy/search index "name:bob AND job:Builder" 10)
(load-file "src/solr.clj")
(with-connection (connect "http://127.0.0.1:8983/solr")
(search "test"))
(with-connection (connect "http://127.0.0.1:8983/solr")
(search "test" {}))
(use 'clojure-solr)
(with-connection (connect "http://127.0.0.1:8983/solr")
(search "test" {}))
(use '(incanter core charts pdf))
(save-pdf (function-plot sin -4 4) "./pdf-chart.pdf")
(load-file "src/pdf.clj")
(load-file "src/incanter_pdf.clj")
(load-file "src/pdf.clj")
